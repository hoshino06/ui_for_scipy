
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>scipy.integrate._ivp.ivp &#8212; ui_for_scipy  ドキュメント</title>
    <link rel="stylesheet" href="../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="検索" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">ui_for_scipy  ドキュメント</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">モジュールコード</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>scipy.integrate._ivp.ivp のソースコード</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.bdf</span> <span class="k">import</span> <span class="n">BDF</span>
<span class="kn">from</span> <span class="nn">.radau</span> <span class="k">import</span> <span class="n">Radau</span>
<span class="kn">from</span> <span class="nn">.rk</span> <span class="k">import</span> <span class="n">RK23</span><span class="p">,</span> <span class="n">RK45</span>
<span class="kn">from</span> <span class="nn">.lsoda</span> <span class="k">import</span> <span class="n">LSODA</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">OptimizeResult</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="k">import</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">OdeSolution</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">OdeSolver</span>


<span class="n">METHODS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;RK23&#39;</span><span class="p">:</span> <span class="n">RK23</span><span class="p">,</span>
           <span class="s1">&#39;RK45&#39;</span><span class="p">:</span> <span class="n">RK45</span><span class="p">,</span>
           <span class="s1">&#39;Radau&#39;</span><span class="p">:</span> <span class="n">Radau</span><span class="p">,</span>
           <span class="s1">&#39;BDF&#39;</span><span class="p">:</span> <span class="n">BDF</span><span class="p">,</span>
           <span class="s1">&#39;LSODA&#39;</span><span class="p">:</span> <span class="n">LSODA</span><span class="p">}</span>


<span class="n">MESSAGES</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;The solver successfully reached the end of the integration interval.&quot;</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;A termination event occurred.&quot;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">OdeResult</span><span class="p">(</span><span class="n">OptimizeResult</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">prepare_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standardize event functions and extract is_terminal and direction.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
        <span class="n">events</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">is_terminal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">is_terminal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">terminal</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">is_terminal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">direction</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_terminal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">events</span><span class="p">,</span> <span class="n">is_terminal</span><span class="p">,</span> <span class="n">direction</span>


<span class="k">def</span> <span class="nf">solve_event_equation</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve an equation corresponding to an ODE event.</span>

<span class="sd">    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an</span>
<span class="sd">    ODE solver using some sort of interpolation. It is solved by</span>
<span class="sd">    `scipy.optimize.brentq` with xtol=atol=4*EPS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event : callable</span>
<span class="sd">        Function ``event(t, y)``.</span>
<span class="sd">    sol : callable</span>
<span class="sd">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span>
<span class="sd">        and  `t`.</span>
<span class="sd">    t_old, t : float</span>
<span class="sd">        Previous and new values of time. They will be used as a bracketing</span>
<span class="sd">        interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root : float</span>
<span class="sd">        Found solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">brentq</span>
    <span class="k">return</span> <span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">event</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                  <span class="n">xtol</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">EPS</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">handle_events</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">is_terminal</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to handle events.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sol : DenseOutput</span>
<span class="sd">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span>
<span class="sd">        and  `t`.</span>
<span class="sd">    events : list of callables, length n_events</span>
<span class="sd">        Event functions with signatures ``event(t, y)``.</span>
<span class="sd">    active_events : ndarray</span>
<span class="sd">        Indices of events which occurred.</span>
<span class="sd">    is_terminal : ndarray, shape (n_events,)</span>
<span class="sd">        Which events are terminal.</span>
<span class="sd">    t_old, t : float</span>
<span class="sd">        Previous and new values of time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root_indices : ndarray</span>
<span class="sd">        Indices of events which take zero between `t_old` and `t` and before</span>
<span class="sd">        a possible termination.</span>
<span class="sd">    roots : ndarray</span>
<span class="sd">        Values of t at which events occurred.</span>
<span class="sd">    terminate : bool</span>
<span class="sd">        Whether a terminal event occurred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event_index</span> <span class="ow">in</span> <span class="n">active_events</span><span class="p">:</span>
        <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solve_event_equation</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">event_index</span><span class="p">],</span> <span class="n">sol</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

    <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_terminal</span><span class="p">[</span><span class="n">active_events</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">t_old</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">active_events</span> <span class="o">=</span> <span class="n">active_events</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">is_terminal</span><span class="p">[</span><span class="n">active_events</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">active_events</span> <span class="o">=</span> <span class="n">active_events</span><span class="p">[:</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[:</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">terminate</span>


<span class="k">def</span> <span class="nf">find_active_events</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_new</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find which event occurred during an integration step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g, g_new : array_like, shape (n_events,)</span>
<span class="sd">        Values of event functions at a current and next points.</span>
<span class="sd">    direction : ndarray, shape (n_events,)</span>
<span class="sd">        Event &quot;direction&quot; according to the definition in `solve_ivp`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    active_events : ndarray</span>
<span class="sd">        Indices of events which occurred during the step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">g_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">g_new</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g_new</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g_new</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">either</span> <span class="o">=</span> <span class="n">up</span> <span class="o">|</span> <span class="n">down</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">up</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
            <span class="n">down</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
            <span class="n">either</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">solve_ivp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dense_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve an initial value problem for a system of ODEs.</span>

<span class="sd">    This function numerically integrates a system of ordinary differential</span>
<span class="sd">    equations given an initial value::</span>

<span class="sd">        dy / dt = f(t, y)</span>
<span class="sd">        y(t0) = y0</span>

<span class="sd">    Here t is a one-dimensional independent variable (time), y(t) is an</span>
<span class="sd">    n-dimensional vector-valued function (state), and an n-dimensional</span>
<span class="sd">    vector-valued function f(t, y) determines the differential equations.</span>
<span class="sd">    The goal is to find y(t) approximately satisfying the differential</span>
<span class="sd">    equations, given an initial value y(t0)=y0.</span>

<span class="sd">    Some of the solvers support integration in the complex domain, but note that</span>
<span class="sd">    for stiff ODE solvers, the right-hand side must be complex-differentiable</span>
<span class="sd">    (satisfy Cauchy-Riemann equations [11]_). To solve a problem in the complex</span>
<span class="sd">    domain, pass y0 with a complex data type. Another option is always to</span>
<span class="sd">    rewrite your problem for real and imaginary parts separately.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        Right-hand side of the system. The calling signature is ``fun(t, y)``.</span>
<span class="sd">        Here ``t`` is a scalar, and there are two options for the ndarray ``y``:</span>
<span class="sd">        It can either have shape (n,); then ``fun`` must return array_like with</span>
<span class="sd">        shape (n,). Alternatively it can have shape (n, k); then ``fun``</span>
<span class="sd">        must return an array_like with shape (n, k), i.e. each column</span>
<span class="sd">        corresponds to a single column in ``y``. The choice between the two</span>
<span class="sd">        options is determined by `vectorized` argument (see below). The</span>
<span class="sd">        vectorized implementation allows a faster approximation of the Jacobian</span>
<span class="sd">        by finite differences (required for stiff solvers).</span>
<span class="sd">    t_span : 2-tuple of floats</span>
<span class="sd">        Interval of integration (t0, tf). The solver starts with t=t0 and</span>
<span class="sd">        integrates until it reaches t=tf.</span>
<span class="sd">    y0 : array_like, shape (n,)</span>
<span class="sd">        Initial state. For problems in the complex domain, pass `y0` with a</span>
<span class="sd">        complex data type (even if the initial guess is purely real).</span>
<span class="sd">    method : string or `OdeSolver`, optional</span>
<span class="sd">        Integration method to use:</span>

<span class="sd">            * &#39;RK45&#39; (default): Explicit Runge-Kutta method of order 5(4) [1]_.</span>
<span class="sd">              The error is controlled assuming accuracy of the fourth-order</span>
<span class="sd">              method, but steps are taken using the fifth-order accurate formula</span>
<span class="sd">              (local extrapolation is done). A quartic interpolation polynomial</span>
<span class="sd">              is used for the dense output [2]_. Can be applied in the complex domain.</span>
<span class="sd">            * &#39;RK23&#39;: Explicit Runge-Kutta method of order 3(2) [3]_. The error</span>
<span class="sd">              is controlled assuming accuracy of the second-order method, but</span>
<span class="sd">              steps are taken using the third-order accurate formula (local</span>
<span class="sd">              extrapolation is done). A cubic Hermite polynomial is used for the</span>
<span class="sd">              dense output. Can be applied in the complex domain.</span>
<span class="sd">            * &#39;Radau&#39;: Implicit Runge-Kutta method of the Radau IIA family of</span>
<span class="sd">              order 5 [4]_. The error is controlled with a third-order accurate</span>
<span class="sd">              embedded formula. A cubic polynomial which satisfies the</span>
<span class="sd">              collocation conditions is used for the dense output.</span>
<span class="sd">            * &#39;BDF&#39;: Implicit multi-step variable-order (1 to 5) method based</span>
<span class="sd">              on a backward differentiation formula for the derivative</span>
<span class="sd">              approximation [5]_. The implementation follows the one described</span>
<span class="sd">              in [6]_. A quasi-constant step scheme is used and accuracy is</span>
<span class="sd">              enhanced using the NDF modification. Can be applied in the complex</span>
<span class="sd">              domain.</span>
<span class="sd">            * &#39;LSODA&#39;: Adams/BDF method with automatic stiffness detection and</span>
<span class="sd">              switching [7]_, [8]_. This is a wrapper of the Fortran solver</span>
<span class="sd">              from ODEPACK.</span>

<span class="sd">        You should use the &#39;RK45&#39; or &#39;RK23&#39; method for non-stiff problems and</span>
<span class="sd">        &#39;Radau&#39; or &#39;BDF&#39; for stiff problems [9]_. If not sure, first try to run</span>
<span class="sd">        &#39;RK45&#39;. If needs unusually many iterations, diverges, or fails, your</span>
<span class="sd">        problem is likely to be stiff and you should use &#39;Radau&#39; or &#39;BDF&#39;.</span>
<span class="sd">        &#39;LSODA&#39; can also be a good universal choice, but it might be somewhat</span>
<span class="sd">        less convenient to work with as it wraps old Fortran code.</span>

<span class="sd">        You can also pass an arbitrary class derived from `OdeSolver` which</span>
<span class="sd">        implements the solver.</span>
<span class="sd">    dense_output : bool, optional</span>
<span class="sd">        Whether to compute a continuous solution. Default is False.</span>
<span class="sd">    t_eval : array_like or None, optional</span>
<span class="sd">        Times at which to store the computed solution, must be sorted and lie</span>
<span class="sd">        within `t_span`. If None (default), use points selected by the solver.</span>
<span class="sd">    events : callable, list of callables or None, optional</span>
<span class="sd">        Types of events to track. Each is defined by a continuous function of</span>
<span class="sd">        time and state that becomes zero value in case of an event. Each function</span>
<span class="sd">        must have the signature ``event(t, y)`` and return a float. The solver will</span>
<span class="sd">        find an accurate value of ``t`` at which ``event(t, y(t)) = 0`` using a</span>
<span class="sd">        root-finding algorithm. Additionally each ``event`` function might have</span>
<span class="sd">        the following attributes:</span>

<span class="sd">            * terminal: bool, whether to terminate integration if this</span>
<span class="sd">              event occurs. Implicitly False if not assigned.</span>
<span class="sd">            * direction: float, direction of a zero crossing. If `direction`</span>
<span class="sd">              is positive, `event` must go from negative to positive, and</span>
<span class="sd">              vice versa if `direction` is negative. If 0, then either direction</span>
<span class="sd">              will count. Implicitly 0 if not assigned.</span>

<span class="sd">        You can assign attributes like ``event.terminal = True`` to any</span>
<span class="sd">        function in Python. If None (default), events won&#39;t be tracked.</span>
<span class="sd">    vectorized : bool, optional</span>
<span class="sd">        Whether `fun` is implemented in a vectorized fashion. Default is False.</span>
<span class="sd">    options</span>
<span class="sd">        Options passed to a chosen solver. All options available for already</span>
<span class="sd">        implemented solvers are listed below.</span>
<span class="sd">    first_step : float or None, optional</span>
<span class="sd">        Initial step size. Default is ``None`` which means that the algorithm</span>
<span class="sd">        should choose.</span>
<span class="sd">    max_step : float, optional</span>
<span class="sd">        Maximum allowed step size. Default is np.inf, i.e. the step size is not</span>
<span class="sd">        bounded and determined solely by the solver.</span>
<span class="sd">    rtol, atol : float and array_like, optional</span>
<span class="sd">        Relative and absolute tolerances. The solver keeps the local error</span>
<span class="sd">        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a</span>
<span class="sd">        relative accuracy (number of correct digits). But if a component of `y`</span>
<span class="sd">        is approximately below `atol`, the error only needs to fall within</span>
<span class="sd">        the same `atol` threshold, and the number of correct digits is not</span>
<span class="sd">        guaranteed. If components of y have different scales, it might be</span>
<span class="sd">        beneficial to set different `atol` values for different components by</span>
<span class="sd">        passing array_like with shape (n,) for `atol`. Default values are</span>
<span class="sd">        1e-3 for `rtol` and 1e-6 for `atol`.</span>
<span class="sd">    jac : {None, array_like, sparse_matrix, callable}, optional</span>
<span class="sd">        Jacobian matrix of the right-hand side of the system with respect to</span>
<span class="sd">        y, required by the &#39;Radau&#39;, &#39;BDF&#39; and &#39;LSODA&#39; method. The Jacobian matrix</span>
<span class="sd">        has shape (n, n) and its element (i, j) is equal to ``d f_i / d y_j``.</span>
<span class="sd">        There are three ways to define the Jacobian:</span>

<span class="sd">            * If array_like or sparse_matrix, the Jacobian is assumed to</span>
<span class="sd">              be constant. Not supported by &#39;LSODA&#39;.</span>
<span class="sd">            * If callable, the Jacobian is assumed to depend on both</span>
<span class="sd">              t and y; it will be called as ``jac(t, y)`` as necessary.</span>
<span class="sd">              For the &#39;Radau&#39; and &#39;BDF&#39; methods, the return value might be a</span>
<span class="sd">              sparse matrix.</span>
<span class="sd">            * If None (default), the Jacobian will be approximated by</span>
<span class="sd">              finite differences.</span>

<span class="sd">        It is generally recommended to provide the Jacobian rather than</span>
<span class="sd">        relying on a finite-difference approximation.</span>
<span class="sd">    jac_sparsity : {None, array_like, sparse matrix}, optional</span>
<span class="sd">        Defines a sparsity structure of the Jacobian matrix for a</span>
<span class="sd">        finite-difference approximation. Its shape must be (n, n). This argument</span>
<span class="sd">        is ignored if `jac` is not `None`. If the Jacobian has only few non-zero</span>
<span class="sd">        elements in *each* row, providing the sparsity structure will greatly</span>
<span class="sd">        speed up the computations [10]_. A zero entry means that a corresponding</span>
<span class="sd">        element in the Jacobian is always zero. If None (default), the Jacobian</span>
<span class="sd">        is assumed to be dense.</span>
<span class="sd">        Not supported by &#39;LSODA&#39;, see `lband` and `uband` instead.</span>
<span class="sd">    lband, uband : int or None</span>
<span class="sd">        Parameters defining the bandwidth of the Jacobian for the &#39;LSODA&#39; method,</span>
<span class="sd">        i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``. Setting</span>
<span class="sd">        these requires your jac routine to return the Jacobian in the packed format:</span>
<span class="sd">        the returned array must have ``n`` columns and ``uband + lband + 1``</span>
<span class="sd">        rows in which Jacobian diagonals are written. Specifically</span>
<span class="sd">        ``jac_packed[uband + i - j , j] = jac[i, j]``. The same format is used</span>
<span class="sd">        in `scipy.linalg.solve_banded` (check for an illustration).</span>
<span class="sd">        These parameters can be also used with ``jac=None`` to reduce the</span>
<span class="sd">        number of Jacobian elements estimated by finite differences.</span>
<span class="sd">    min_step : float, optional</span>
<span class="sd">        The minimum allowed step size for &#39;LSODA&#39; method. </span>
<span class="sd">        By default `min_step` is zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bunch object with the following fields defined:</span>
<span class="sd">    t : ndarray, shape (n_points,)</span>
<span class="sd">        Time points.</span>
<span class="sd">    y : ndarray, shape (n, n_points)</span>
<span class="sd">        Values of the solution at `t`.</span>
<span class="sd">    sol : `OdeSolution` or None</span>
<span class="sd">        Found solution as `OdeSolution` instance; None if `dense_output` was</span>
<span class="sd">        set to False.</span>
<span class="sd">    t_events : list of ndarray or None</span>
<span class="sd">        Contains for each event type a list of arrays at which an event of</span>
<span class="sd">        that type event was detected. None if `events` was None.</span>
<span class="sd">    nfev : int</span>
<span class="sd">        Number of evaluations of the right-hand side.</span>
<span class="sd">    njev : int</span>
<span class="sd">        Number of evaluations of the Jacobian.</span>
<span class="sd">    nlu : int</span>
<span class="sd">        Number of LU decompositions.</span>
<span class="sd">    status : int</span>
<span class="sd">        Reason for algorithm termination:</span>

<span class="sd">            * -1: Integration step failed.</span>
<span class="sd">            *  0: The solver successfully reached the end of `tspan`.</span>
<span class="sd">            *  1: A termination event occurred.</span>

<span class="sd">    message : string</span>
<span class="sd">        Human-readable description of the termination reason.</span>
<span class="sd">    success : bool</span>
<span class="sd">        True if the solver reached the interval end or a termination event</span>
<span class="sd">        occurred (``status &gt;= 0``).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta</span>
<span class="sd">           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6,</span>
<span class="sd">           No. 1, pp. 19-26, 1980.</span>
<span class="sd">    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics</span>
<span class="sd">           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.</span>
<span class="sd">    .. [3] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;,</span>
<span class="sd">           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.</span>
<span class="sd">    .. [4] E. Hairer, G. Wanner, &quot;Solving Ordinary Differential Equations II:</span>
<span class="sd">           Stiff and Differential-Algebraic Problems&quot;, Sec. IV.8.</span>
<span class="sd">    .. [5] `Backward Differentiation Formula</span>
<span class="sd">            &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_</span>
<span class="sd">            on Wikipedia.</span>
<span class="sd">    .. [6] L. F. Shampine, M. W. Reichelt, &quot;THE MATLAB ODE SUITE&quot;, SIAM J. SCI.</span>
<span class="sd">           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.</span>
<span class="sd">    .. [7] A. C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE</span>
<span class="sd">           Solvers,&quot; IMACS Transactions on Scientific Computation, Vol 1.,</span>
<span class="sd">           pp. 55-64, 1983.</span>
<span class="sd">    .. [8] L. Petzold, &quot;Automatic selection of methods for solving stiff and</span>
<span class="sd">           nonstiff systems of ordinary differential equations&quot;, SIAM Journal</span>
<span class="sd">           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,</span>
<span class="sd">           1983.</span>
<span class="sd">    .. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on</span>
<span class="sd">           Wikipedia.</span>
<span class="sd">    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, &quot;On the estimation of</span>
<span class="sd">            sparse Jacobian matrices&quot;, Journal of the Institute of Mathematics</span>
<span class="sd">            and its Applications, 13, pp. 117-120, 1974.</span>
<span class="sd">    .. [11] `Cauchy-Riemann equations</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on</span>
<span class="sd">             Wikipedia.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic exponential decay showing automatically chosen time points.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.integrate import solve_ivp</span>
<span class="sd">    &gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y</span>
<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [  0.           0.11487653   1.26364188   3.06061781   4.85759374</span>
<span class="sd">       6.65456967   8.4515456   10.        ]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.y)</span>
<span class="sd">    [[2.         1.88836035 1.06327177 0.43319312 0.17648948 0.0719045</span>
<span class="sd">      0.02929499 0.01350938]</span>
<span class="sd">     [4.         3.7767207  2.12654355 0.86638624 0.35297895 0.143809</span>
<span class="sd">      0.05858998 0.02701876]</span>
<span class="sd">     [8.         7.5534414  4.25308709 1.73277247 0.7059579  0.287618</span>
<span class="sd">      0.11717996 0.05403753]]</span>

<span class="sd">    Specifying points where the solution is desired.</span>

<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],</span>
<span class="sd">    ...                 t_eval=[0, 1, 2, 4, 10])</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [ 0  1  2  4 10]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.y)</span>
<span class="sd">    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]</span>
<span class="sd">     [4.         2.42610739 1.47068043 0.54133472 0.02701876]</span>
<span class="sd">     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]</span>

<span class="sd">    Cannon fired upward with terminal event upon impact. The ``terminal`` and</span>
<span class="sd">    ``direction`` fields of an event are applied by monkey patching a function.</span>
<span class="sd">    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts at</span>
<span class="sd">    position 0 with velocity +10. Note that the integration never reaches t=100</span>
<span class="sd">    because the event is terminal.</span>

<span class="sd">    &gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]</span>
<span class="sd">    &gt;&gt;&gt; def hit_ground(t, y): return y[1]</span>
<span class="sd">    &gt;&gt;&gt; hit_ground.terminal = True</span>
<span class="sd">    &gt;&gt;&gt; hit_ground.direction = -1</span>
<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t_events)</span>
<span class="sd">    [array([ 20.])]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02</span>
<span class="sd">     1.11088891e-01 1.11098890e+00 1.11099890e+01 2.00000000e+01]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">OdeSolver</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`method` must be one of </span><span class="si">{}</span><span class="s2"> or OdeSolver class.&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">METHODS</span><span class="p">))</span>

    <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_span</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_eval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t_eval</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`t_eval` must be 1-dimensional.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_eval</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_eval</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values in `t_eval` are not within `t_span`.&quot;</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_eval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tf</span> <span class="o">&gt;</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tf</span> <span class="o">&lt;</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values in `t_eval` are not properly sorted.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tf</span> <span class="o">&gt;</span> <span class="n">t0</span><span class="p">:</span>
            <span class="n">t_eval_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make order of t_eval decreasing to use np.searchsorted.</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># This will be an upper bound for slices.</span>
            <span class="n">t_eval_i</span> <span class="o">=</span> <span class="n">t_eval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">METHODS</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

    <span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="n">vectorized</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">y0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dense_output</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">interpolants</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">events</span><span class="p">,</span> <span class="n">is_terminal</span><span class="p">,</span> <span class="n">event_dir</span> <span class="o">=</span> <span class="n">prepare_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">status</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;finished&#39;</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;failed&#39;</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>

        <span class="n">t_old</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">t_old</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">t</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">y</span>

        <span class="k">if</span> <span class="n">dense_output</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>
            <span class="n">interpolants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>
            <span class="n">active_events</span> <span class="o">=</span> <span class="n">find_active_events</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_new</span><span class="p">,</span> <span class="n">event_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">active_events</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>

                <span class="n">root_indices</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">terminate</span> <span class="o">=</span> <span class="n">handle_events</span><span class="p">(</span>
                    <span class="n">sol</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">is_terminal</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">te</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">root_indices</span><span class="p">,</span> <span class="n">roots</span><span class="p">):</span>
                    <span class="n">t_events</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">te</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">terminate</span><span class="p">:</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">sol</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">g</span> <span class="o">=</span> <span class="n">g_new</span>

        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The value in t_eval equal to t will be included.</span>
            <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">t_eval_i_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
                <span class="n">t_eval_step</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[</span><span class="n">t_eval_i</span><span class="p">:</span><span class="n">t_eval_i_new</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_eval_i_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="c1"># It has to be done with two slice operations, because</span>
                <span class="c1"># you can&#39;t slice to 0-th element inclusive using backward</span>
                <span class="c1"># slicing.</span>
                <span class="n">t_eval_step</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[</span><span class="n">t_eval_i_new</span><span class="p">:</span><span class="n">t_eval_i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">t_eval_step</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_eval_step</span><span class="p">)</span>
                <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">(</span><span class="n">t_eval_step</span><span class="p">))</span>
                <span class="n">t_eval_i</span> <span class="o">=</span> <span class="n">t_eval_i_new</span>
        
        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dense_output</span><span class="p">:</span>
            <span class="n">ti</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">message</span> <span class="o">=</span> <span class="n">MESSAGES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">t_events</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dense_output</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">OdeSolution</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">interpolants</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">OdeSolution</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">interpolants</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">OdeResult</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ys</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">t_events</span><span class="o">=</span><span class="n">t_events</span><span class="p">,</span> <span class="n">nfev</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span>
                     <span class="n">njev</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">njev</span><span class="p">,</span> <span class="n">nlu</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">nlu</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">,</span>
                     <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">ui_for_scipy  ドキュメント</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >モジュールコード</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Hikaru Hoshino.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5 で生成しました。
    </div>
  </body>
</html>